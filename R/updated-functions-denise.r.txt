#' Overall Sample Size
#'
#' Calculates the sample size required to detect a given set of effects 
#' in a two-stage randomized clinical trial. Returns the largest
#' of the required sample sizes for a given set of treatment, selection, and 
#' preference effects.
#'
#' @param power desired study power. Should be numeric value between 0 and 1.
#' @param phi the proportion of patients preferring treatment 1. Should be
#'            numeric value between 0 and 1. If study is stratified, should be
#'            vector with length equal to the number of strata in the study.
#' @param sigma2 variance estimate. Should be positive numeric values. If study
#'               is stratified, should be vector of within-stratum variances 
#'               with length equal to the number of strata in the study.
#' @param delta_pi overall study preference effect.
#' @param delta_nu overall study selection effect.
#' @param delta_tau overall study treatment effect.
#' @param alpha desired type I error rate.
#' @param theta proportion of patients assigned to choice arm in the initial
#'              randomization. Should be numeric value between
#'              0 and 1 (default=0.5).
#' @param xi a numeric vector of the proportion of patients in each stratum. 
#'          Length of vector should equal the number of strata in the study and 
#'          sum of vector should be 1. All vector elements should be numeric 
#'          values between 0 and 1. Default is 1 (i.e. unstratified design).
#' @param nstrata number of strata. Default is 1 (i.e. unstratified design).
#'@param k the ratio of treatment A to treatment B in the random arm. (default 1, i.e. equal
#' distribution to the two treatments in the random arm)
#' @references Turner RM, et al. (2014). "Sample Size and Power When Designing
#'  a Randomized Trial for the Estimation of Treatment, Selection, and 
#'  Preference Effects." \emph{Medical Decision Making}, \strong{34}:711-719.
#' (\href{https://www.ncbi.nlm.nih.gov/pubmed/24695962}{PubMed})
#' @references Cameron B, Esserman D (2016). "Sample Size and Power for a 
#' Stratified Doubly Randomized Preference Design." \emph{Stat Methods Med Res}. 
#' (\href{https://www.ncbi.nlm.nih.gov/pubmed/27872194}{PubMed})
overall_sample_size <- function(power, phi, sigma2, delta_pi, delta_nu, 
                                delta_tau, alpha=0.05, theta=0.5, xi=1, nstrata=1, k=1) {
  
  zbeta <- qnorm(power)
  zalpha <- qnorm(1-(alpha/2))
  
  # selection sample size  
  sel_terms <- vapply(seq_len(nstrata), 
                  function(x) {
                    (xi[x]/(phi[x]^2*(1-phi[x])^2)) *
                      (sigma2[x]+phi[x]*(1-phi[x])*((2*phi[x]-1)*delta_nu+delta_pi)^2 +
                         2*(theta/(1-theta))*sigma2[x]*(phi[x]^2+(1-phi[x])^2))
                  }, 0.0)
  sel_sum_total <- sum(sel_terms)
  sel_N <- ceiling((zalpha+zbeta)^2/(4*theta*delta_nu^2)*sel_sum_total)
  
  #preference sample size
  pref_terms <- vapply(seq_len(nstrata), 
                  function(x) {
                    (xi[x] / (phi[x]^2 * (1-phi[x])^2)) *
                      (sigma2[x] + phi[x] * (1-phi[x]) * ((2*phi[x]-1)*delta_pi+delta_nu)^2 +
                         2*(theta/(1-theta)) * sigma2[x]*(phi[x]^2+(1-phi[x])^2))
                  }, 0.0)
  pref_sum_total <- sum(pref_terms)
  pref_N <- ceiling((zalpha+zbeta)^2 / (4*theta*delta_pi^2) * pref_sum_total)

  #Treatment sample size
  
  treat_terms <- vapply(seq_len(nstrata), function(x) xi[x]*sigma2[x], 0.0)
  treat_sum_total <- sum(treat_terms)
  treat_N <- ceiling(((k+1)^2 / (4*k)) * 4 * (zalpha+zbeta)^2 / ((1-theta)*delta_tau^2) * treat_sum_total)
  
  data.frame(treatment=treat_N, selection=sel_N, preference=pref_N) 
}


#' Power Calculation from Sample Size
#'
#' Calculates the study power to detect a set of effects given a particular 
#' sample size in a two-stage randomized clinical trial
#'
#' @param N overall study sample size.
#' @param phi the proportion of patients preferring treatment 1. Should be
#'            numeric value between 0 and 1. If study is stratified, should be
#'            vector with length equal to the number of strata in the study.
#' @param sigma2 variance estimate. Should be positive numeric values. If study
#'               is stratified, should be vector of within-stratum variances 
#'               with length equal to the number of strata in the study.
#' @param delta_pi overall study preference effect.
#' @param delta_nu overall study selection effect.
#' @param delta_tau overall study treatment effect.
#' @param alpha desired type I error rate.
#' @param theta proportion of patients assigned to choice arm in the initial
#'              randomization. Should be numeric value between
#'              0 and 1 (default=0.5).
#' @param xi a numeric vector of the proportion of patients in each stratum. 
#'          Length of vector should equal the number of strata in the study and 
#'          sum of vector should be 1. All vector elements should be numeric 
#'          values between 0 and 1. Default is 1 (i.e. unstratified design).
#' @param nstrata number of strata. Default is 1 (i.e. unstratified design).
#' @references Turner RM, et al. (2014). "Sample Size and Power When Designing
#'  a Randomized Trial for the Estimation of Treatment, Selection, and 
#'  Preference Effects." \emph{Medical Decision Making}, \strong{34}:711-719.
#' (\href{https://www.ncbi.nlm.nih.gov/pubmed/24695962}{PubMed})
#' @references Cameron B, Esserman D (2016). "Sample Size and Power for a 
#' Stratified Doubly Randomized Preference Design." \emph{Stat Methods Med Res}. 
#' (\href{https://www.ncbi.nlm.nih.gov/pubmed/27872194}{PubMed})
overall_power<-function(N, phi, sigma2, delta_pi, delta_nu, delta_tau, 
                        alpha=0.05, theta=0.5, xi=1, nstrata=1) {
  
  zalpha <- qnorm(1-(alpha/2))
  # Calculate study power for treatment effect
  
  treat_strata_terms <- vapply(seq_len(nstrata),
                         function(i) xi[i] * sigma2[i],
                         0.0)
  trt_pwr <- pnorm( sqrt( ((1-theta)*delta_tau^2*N) / (4*sum(treat_strata_terms)) ) - zalpha )
  
  #Calculate study power for preference effect
  pref_strata_terms <- vapply(seq_len(nstrata), 
                         function(x) {
                           ( xi[x] / (phi[x]^2*(1-phi[x])^2) ) * 
                             ( sigma2[x] + phi[x]*(1-phi[x])*
                                 ( (2*phi[x]-1)*delta_pi+delta_nu )^2 +
                                 2* (theta / (1-theta)) *sigma2[x] * ( phi[x]^2+(1-phi[x])^2 ) )
                         }, 0.0)
  pref_sum_total <- sum(pref_strata_terms)

  pref_pwr <- pnorm( sqrt( (4*theta*delta_pi^2*N) / pref_sum_total ) - zalpha )
  
  #Calcualte study power for preference effect
  sel_strata_terms <- vapply(seq_len(nstrata), 
                         function(x) {
                           ( xi[x] / (phi[x]^2 *(1 - phi[x])^2) ) *
                             ( sigma2[x] + phi[x] *(1 - phi[x]) * 
                                 ( (2 * phi[x] - 1) * delta_nu + delta_pi )^2 +
                                 2 * (theta / (1-theta) ) * sigma2[x] * (phi[x]^2 + (1-phi[x])^2) )
                         }, 0.0)
  sel_sum_total <- sum(strata_terms)
  sel_pwr <- pnorm(sqrt((4*theta*delta_nu^2*N)/(sel_sum_total))-zalpha)
  
  data.frame(treatment = trt_pwr, selection = sel_pwr, preference = pref_pwr)
}


#################################################################################


#' Analysis Function: Summary Data
#' 
#' Computes the test statistic and p-value for the preference, selection, and 
#' treatment effects for the two-stage randomized trial using provided summary 
#' data
#' 
#' @param x1mean mean of responses for patients choosing treatment 1. If study
#'               is stratified, should be vector with length equal to the
#'               number of strata.
#' @param x1var variance of responses for patients choosing treatment 1. If 
#'              study is stratified, should be vector with length equal to the
#'              number of strata.
#' @param m1 number of patients choosing treatment 1. If study
#'               is stratified, should be vector with length equal to the
#'               number of strata.
#' @param x2mean mean of responses for patients choosing treatment 2. If study
#'               is stratified, should be vector with length equal to the
#'               number of strata.
#' @param x2var variance of responses for patients choosing treatment 2. If 
#'              study is stratified, should be vector with length equal to the
#'              number of strata.
#' @param m2 number of patients choosing treatment 2. If study
#'               is stratified, should be vector with length equal to the
#'               number of strata.
#' @param y1mean mean of responses for patients randomized to treatment 1. If 
#'               study is stratified, should be vector with length equal to the
#'               number of strata.
#' @param y1var variance of responses for patients randomized to treatment 1. If 
#'              study is stratified, should be vector with length equal to the
#'              number of strata.
#' @param n1 number of patients randomized to treatment 1. If study is 
#'           stratified, should be vector with length equal to the number of 
#'           strata.
#' @param y2mean mean of responses for patients randomized to treatment 2. If 
#'               study is stratified, should be vector with length equal to the
#'               number of strata.
#' @param y2var variance of responses for patients randomized to treatment 2. If 
#'              study is stratified, should be vector with length equal to the
#'              number of strata.
#' @param n2 number of patients randomized to treatment 2. If study is 
#'           stratified, should be vector with length equal to the number of 
#'           strata.
#' @param xi a numeric vector of the proportion of patients in each stratum. 
#'          Length of vector should equal the number of strata in the study and 
#'          sum of vector should be 1. All vector elements should be numeric 
#'          values between 0 and 1. Default is 1 (i.e. unstratified design).
#' @param nstrata number of strata. Default is 1 (i.e. unstratified design).
#' @param alpha Type I error rate, used to determine confidence interval level 
#'              for the effect estimates. Default is 0.05 (i.e. 95% confidence interval)
#' @examples
#' x1mean <- 5
#' x1var <- 1
#' m1 <- 15
#' x2mean <- 7
#' x2var <- 1.1
#' m2 <- 35
#' y1mean <- 6
#' y1var <- 1
#' n1 <- 25
#' y2mean <- 8
#' y2var <- 1.2
#' n2 <- 25
#' analyze_summary_data(x1mean, x2var, m1, x2mean, x2var, m2, y1mean, y2var,
#'                      n1, y2mean, y2var, n2)
#' @references Rucker G (1989). "A two-stage trial design for testing treatment,
#' self-selection and treatment preference effects." \emph{Stat Med}, 
#' \strong{8}(4):477-485. 
#' (\href{https://www.ncbi.nlm.nih.gov/pubmed/2727471}{PubMed})
#' @references Cameron B, Esserman D (2016). "Sample Size and Power for a 
#' Stratified Doubly Randomized Preference Design." 
#' \emph{Stat Methods Med Res}. 
#' (\href{https://www.ncbi.nlm.nih.gov/pubmed/27872194}{PubMed})
#' @export
analyze_summary_data <- function(x1mean, x1var, m1, x2mean, x2var, m2, y1mean,
                                 y1var, n1, y2mean, y2var, n2, xi=1, 
                                 nstrata=1, alpha=0.05) {
  
  # Compute unstratified test statistics
  unstrat_stats <- vapply(seq_len(nstrata), 
                          function(i) {
                            unstrat_analyze_summary_data(x1mean[i], x1var[i], m1[i], x2mean[i], 
                                                         x2var[i], m2[i], y1mean[i], y1var[i], n1[i],
                                                         y2mean[i], y2var[i], n2[i], alpha)
                          }, data.frame(pref_effect=NA, pref_SE=NA, pref_test = NA, pref_pval = NA, pref_LB=NA, pref_UB=NA,
                                        sel_effect=NA, sel_SE=NA, sel_test = NA , sel_pval = NA, sel_LB=NA, sel_UB=NA, 
                                        treat_effect=NA, treat_SE=NA, treat_test = NA, treat_pval = NA, treat_LB=NA, treat_UB=NA))
  
  #Calculate the overall effect estimate
  overall_pref_effect <- sum(
    vapply(seq_len(nstrata), 
           function(i) xi[i] * unlist(unstrat_stats[1, i]), 0.0))
  
  overall_sel_effect <- sum(
    vapply(seq_len(nstrata), 
           function(i) xi[i] * unlist(unstrat_stats[7, i]), 0.0))
  
  overall_treat_effect <- sum(
    vapply(seq_len(nstrata),
           function(i) xi[i] * unlist(unstrat_stats[13, i]), 0.0))
  
  #Calculate the overall SE
  overall_pref_SE <- sqrt(sum(
    vapply(seq_len(nstrata), 
           function(i) xi[i]^2 * unlist(unstrat_stats[2, i])^2, 0.0)))
  
  overall_sel_SE <- sqrt(sum(
    vapply(seq_len(nstrata), 
           function(i) xi[i]^2 * unlist(unstrat_stats[8, i])^2, 0.0)))
  
  overall_treat_SE <- sqrt(sum(
    vapply(seq_len(nstrata),
           function(i) xi[i]^2 * unlist(unstrat_stats[14, i])^2, 0.0)))
  
  #Calculate overall test statistic
  overall_pref_test <- overall_pref_effect/overall_pref_SE
  
  overall_sel_test <- overall_sel_effect/overall_sel_SE
  
  overall_treat_test <- overall_treat_effect/overall_treat_SE
  
  # Compute p-values (Assume test stats approximately normally distributed)
  
  # preference effect
  overall_pref_pval <- 2 * pnorm(abs(overall_pref_test), lower.tail = FALSE)
  
  # selection effect
  overall_sel_pval <- 2 * pnorm(abs(overall_sel_test), lower.tail = FALSE) 
  
  # treatment effect
  overall_treat_pval <- 2 * pnorm(abs(overall_treat_test), lower.tail = FALSE)
  
#Compute the upper and lower bounds of the confidence interval

  zalpha <- qnorm(1-(alpha/2))
  
  overall_pref_LB <- overall_pref_effect - zalpha*overall_pref_SE
  
  overall_pref_UB <- overall_pref_effect + zalpha*overall_pref_SE
  
  overall_sel_LB <- overall_sel_effect - zalpha*overall_sel_SE
  
  overall_sel_UB <- overall_sel_effect + zalpha*overall_sel_SE
  
  overall_treat_LB <- overall_treat_effect - zalpha*overall_treat_SE
  
  overall_treat_UB <- overall_treat_effect + zalpha*overall_treat_SE

  overall_stats<-data.frame(overall_pref_effect=overall_pref_effect, overall_pref_SE=overall_pref_SE, overall_pref_test=overall_pref_test,
                          overall_pref_pval=overall_pref_pval, overall_pref_LB=overall_pref_LB, overall_pref_UB=overall_pref_UB,
                          overall_sel_effect=overall_sel_effect, overall_sel_SE=overall_sel_SE, overall_sel_test=overall_sel_test,
                          overall_sel_pval=overall_sel_pval, overall_sel_LB=overall_sel_LB, overall_sel_UB=overall_sel_UB,
                          overall_treat_effect=overall_treat_effect, overall_treat_SE=overall_treat_SE, overall_treat_test=overall_treat_test,
                          overall_treat_pval=overall_treat_pval, overall_treat_LB=overall_treat_LB, overall_treat_UB=overall_treat_UB)
  

  ret<-list(unstratified_statistics=unstrat_stats, overall_statistics=overall_stats) 
  return(ret)
}


### Analysis Function (Summary Data)
unstrat_analyze_summary_data <- function(x1mean, x1var, m1, x2mean, x2var, m2, 
                                         y1mean, y1var, n1, y2mean, y2var, n2, alpha) {
  # Define sample sizes
  m <- m1 + m2
  
  n <- n1 + n2
  
  N <- m + n
  
  # Calculate z values as defined by Rucker
  z1 <- m1*x1mean - m1*y1mean
  
  z2 <- m2*x2mean - m2*y2mean
  
  # Calculate variance components (formulas from Rucker paper)
  var1 <- m1*x1var + (1 + ((m - 1)/m)*m1)*m1*(y1var/n1) + (m1*m2/m)*(x1mean - y1mean)^2

  var2 <- m2*x2var + (1 + ((m - 1)/m)*m2)*m2*(y2var/n2) + (m1*m2/m)*(x2mean - y2mean)^2
  
  cov <- -(m1*m2/m)*(x1mean - y1mean)*(x2mean - y2mean)
  
  #Call the test2 function
  treat_out <- t.test2(y1mean,y2mean,y1var,y2var,n1,n2)
  
  # Compute effect estimates 
  
  pref_effect <- 0.5*(m/(m1*m2))*(z1+z2)

  sel_effect <- 0.5*(m/(m1*m2))*(z1-z2)
    
  treat_effect <- treat_out$Mean.Diff
  
  #Compute SE estimates 
  pref_SE <- sqrt(var1 + var2 + 2*cov)*0.5*(m/(m1*m2))

  sel_SE <- sqrt(var1 + var2 - 2*cov)*0.5*(m/(m1*m2))
  
  treat_SE <- treat_out$Std.Err
  
  # Compute test statistics 
  pref_test <- pref_effect/pref_SE 
  
  sel_test <- sel_effect/sel_SE 
  
  treat_test <- treat_out$t
  
  # Compute p-values (Assume test stats approximately normally distributed)
  pref_pval <- pnorm(abs(pref_test), lower.tail = FALSE)*2 # Preference effect
  
  sel_pval <- pnorm(abs(sel_test), lower.tail = FALSE)*2 # Selection effect
  
  treat_pval <- treat_out$p.value
  
  #Compute approximate (1-alpha)% confidence intervals
  zalpha <- qnorm(1 - (alpha/2))
  
  pref_LB <- pref_effect - zalpha*pref_SE
  
  pref_UB <- pref_effect + zalpha*pref_SE
  
  sel_LB <- sel_effect - zalpha*sel_SE
  
  sel_UB <- sel_effect + zalpha*sel_SE
  
  treat_LB <- treat_effect - zalpha*treat_SE
  
  treat_UB <- treat_effect + zalpha*treat_SE
  

  data.frame(pref_effect, pref_SE, pref_test, pref_pval,pref_LB, pref_UB,
             sel_effect, sel_SE, sel_test, sel_pval, sel_LB, sel_UB,
             treat_effect, treat_SE,  treat_test, treat_pval, treat_LB, treat_UB)
}


### T-test from summary data (null hypothesis of no difference, no assumption 
# of equal variances)
# m1,m1: sample means
# s1,s2: sample variances
# n1, n2: sample sizes

#' @importFrom stats pt
t.test2 <- function(m1,m2,s1,s2,n1,n2)
{
  se <- sqrt( (s1/n1) + (s2/n2) )
  
  # Welch-satterthwaite df
  df <- ( (s1/n1 + s2/n2)^2 )/( (s1/n1)^2/(n1-1) + (s2/n2)^2/(n2-1) )
  
  t <- (m1 - m2)/se 
  
  dat <- data.frame(m1-m2, se, t, 2*pt(-abs(t),df))    
  
  names(dat) <- c("Mean.Diff", "Std.Err", "t", "p.value")
  
  dat
}

